---
layout:     post
title:      ES6知识点总结整理
subtitle:   H.T. Blog 知识点整理持续更新...
date:       2019-12-03
author:     haotian
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - ES6知识点总结整理
---

## 文章目录
1. ES6知识点总结整理目录

## 1、 Set、Map、WeakSet 和 WeakMap 的区别？
<b>Set</b>

    成员唯一、无序且不重复
    [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
    可以遍历，方法有：add、delete、has

<b>WeakSet</b>

    成员都是对象
    成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
    不能遍历，方法有add、delete、has

<b>Map</b>

    本质上是键值对的集合，类似集合
    可以遍历，方法很多可以跟各种数据格式转换

<b>WeakMap</b>

    只接受对象作为键名（null除外），不接受其他类型的值作为键名
    键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
    不能遍历，方法有get、set、has、delete
    
<b>遍历方法</b>

    keys()：将字典中包含的所有键名以迭代器形式返回
    values()：将字典中包含的所有数值以迭代器形式返回
    entries()：返回所有成员的迭代器
    forEach()：遍历字典的所有成员

## 2、async/await 如何通过同步的方式实现异步？
    async/await 是参照 Generator 封装的一套异步处理方案，可以理解为 Generator 的语法糖，

    所以了解 async/await 就不得不讲一讲 Generator,

    而 Generator 又依赖于迭代器Iterator，

    所以就得先讲一讲 Iterator,

    而 Iterator 的思想呢又来源于单向链表，

    终于找到源头了：单向链表

## 3、Proxy 简介
1、定义：修改某些操作的默认行为；

2、声明：

    const proxy = new Proxy(target, handler)

3、入参：

    target：拦截的目标对象
    handler：定制拦截行为

4、方法

    Proxy.revocable()：返回可取消的Proxy实例(返回{ proxy, revoke }，通过revoke()取消代理)

5、拦截方式

    get()：拦截对象属性读取

    set()：拦截对象属性设置，返回布尔

    has()：拦截对象属性检查k in obj，返回布尔
    
    deleteProperty()：拦截对象属性删除delete obj[k]，返回布尔

    defineProperty()：拦截对象属性定义Object.defineProperty()、Object.defineProperties()，返回布尔

    ownKeys()：拦截对象属性遍历for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组

    getOwnPropertyDescriptor()：拦截对象属性描述读取Object.getOwnPropertyDescriptor()，返回对象
    
    getPrototypeOf()：拦截对象原型读取instanceof、
    Object.getPrototypeOf()、Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象
    
    setPrototypeOf()：拦截对象原型设置Object.setPrototypeOf()，返回布尔

    isExtensible()：拦截对象是否可扩展读取Object.isExtensible()，返回布尔

    preventExtensions()：拦截对象不可扩展设置Object.preventExtensions()，返回布尔

    apply()：拦截Proxy实例作为函数调用proxy()、proxy.apply()、proxy.call()

    construct()：拦截Proxy实例作为构造函数调用new proxy()

应用场景

    Proxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问

    get()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点

    set()：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写

    has()：隐藏内部属性不被发现、排除不符合属性条件的对象

    deleteProperty()：保护内部属性不被删除

    defineProperty()：阻止属性被外部定义

    ownKeys()：保护内部属性不被遍历

重点难点

    要使Proxy起作用，必须针对实例进行操作，而不是针对目标对象进行操作
    没有设置任何拦截时，等同于直接通向原对象
    属性被定义为不可读写/扩展/配置/枚举时，使用拦截方法会报错
    代理下的目标对象，内部this指向Proxy代理

## 4、Reflect 简介

1、定义：保持Object方法的默认行为

2、方法

    get()：返回对象属性

    set()：设置对象属性，返回布尔

    has()：检查对象属性，返回布尔

    deleteProperty()：删除对象属性，返回布尔

    defineProperty()：定义对象属性，返回布尔

    ownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())
    getOwnPropertyDescriptor()：返回对象属性描述，返回对象

    getPrototypeOf()：返回对象原型，返回对象

    setPrototypeOf()：设置对象原型，返回布尔

    isExtensible()：返回对象是否可扩展，返回布尔

    preventExtensions()：设置对象不可扩展，返回布尔

    apply()：绑定this后执行指定函数

    construct()：调用构造函数创建实例

设计目的

    将Object属于语言内部的方法放到Reflect上
    将某些Object方法报错情况改成返回false
    让Object操作变成函数行为
    Proxy与Reflect相辅相成

重点难点

    Proxy方法和Reflect方法一一对应

    Proxy和Reflect联合使用，前者负责拦截赋值操作，后者负责完成赋值操作

数据绑定：观察者模式

```js
    const observerQueue = new Set();
    const observe = fn => observerQueue.add(fn);
    const observable = obj => new Proxy(obj, {
        set(tgt, key, val, receiver) {
            const result = Reflect.set(tgt, key, val, receiver);
            observerQueue.forEach(v => v());
            return result;
        }
    });

    const person = observable({ age: 25, name: "Yajun" });
    const print = () => console.log(`${person.name} is ${person.age} years old`);
    observe(print);
    person.name = "Joway";
```

## 6、Class
1、定义：对一类具有共同特征的事物的抽象(构造函数语法糖)

2、原理：

    类本身指向构造函数，所有方法定义在prototype上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)

3、方法和关键字

    constructor()：构造函数，new命令生成实例时自动调用
    extends：继承父类
    super：新建父类的this
    static：定义静态属性方法
    get：取值函数，拦截属性的取值行为
    set：存值函数，拦截属性的存值行为

4、属性

    __proto__：构造函数的继承(总是指向父类)
    __proto__.__proto__：子类的原型的原型，即父类的原型(总是指向父类的__proto__)
    prototype.__proto__：属性方法的继承(总是指向父类的prototype)

5、静态属性：

    定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用

6、静态方法：

    使用static定义方法，该方法不会被实例继承，只能通过类来调用(方法中的this指向类，而不是实例)
    
7、继承

    实质

        ES5实质：先创造子类实例的this，再将父类的属性方法添加到this上(Parent.apply(this))

        ES6实质：先将父类实例的属性方法加到this上(调用super())，再用子类构造函数修改this

    super

        作为函数调用：只能在构造函数中调用super()，内部this指向继承的当前子类(super()调用后才可在构造函数中使用this)

        作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类

    显示定义：使用constructor() { super(); }定义继承父类，没有书写则显示定义

    子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用super()，否则得不到父类的this

        父类静态属性方法可被子类继承
        子类继承父类后，可从super上调用父类静态属性方法

8、实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承

    显式指定属性方法：使用this指定到自身上(使用Class.hasOwnProperty()可检测到)
    隐式指定属性方法：直接声明定义在对象原型上(使用Class.__proto__.hasOwnProperty()可检测到)

9、表达式

    类表达式：const Class = class {}
    name属性：返回紧跟class后的类名
    属性表达式：[prop]
    Generator方法：* mothod() {}
    Async方法：async mothod() {}

10、this指向：解构实例属性或方法时会报错

    绑定this：this.mothod = this.mothod.bind(this)
    箭头函数：this.mothod = () => this.mothod()

11、属性定义位置

    定义在构造函数中并使用this指向
    定义在类最顶层

12、new.target：确定构造函数是如何调用

13、原生构造函数

    String()
    Number()
    Boolean()
    Array()
    Object()
    Function()
    Date()
    RegExp()
    Error()

14、重点难点

    在实例上调用方法，实质是调用原型上的方法

    Object.assign()可方便地一次向类添加多个方法(Object.assign(Class.prototype, { ... }))

    类内部所有定义的方法是不可枚举的(non-enumerable)

    构造函数默认返回实例对象(this)，可指定返回另一个对象

    取值函数和存值函数设置在属性的Descriptor对象上

    类不存在变量提升

    利用new.target === Class写出不能独立使用必须继承后才能使用的类

    子类继承父类后，this指向子类实例，通过super对某个属性赋值，赋值的属性会变成子类实例的属性

    使用super时，必须显式指定是作为函数还是作为对象使用

    extends不仅可继承类还可继承原生的构造函数

私有属性方法

    const name = Symbol("name");
    const print = Symbol("print");
    class Person {
        constructor(age) {
            this[name] = "Bruce";
            this.age = age;
        }
        [print]() {
            console.log(`${this[name]} is ${this.age} years old`);
        }
    }

继承混合类

    function CopyProperties(target, source) {
        for (const key of Reflect.ownKeys(source)) {
            if (key !== "constructor" && key !== "prototype" && key !== "name") {
                const desc = Object.getOwnPropertyDescriptor(source, key);
                Object.defineProperty(target, key, desc);
            }
        }
    }
    function MixClass(...mixins) {
        class Mix {
            constructor() {
                for (const mixin of mixins) {
                    CopyProperties(this, new mixin());
                }
            }
        }
        for (const mixin of mixins) {
            CopyProperties(Mix, mixin);
            CopyProperties(Mix.prototype, mixin.prototype);
        }
        return Mix;
    }
    class Student extends MixClass(Person, Kid) {}
