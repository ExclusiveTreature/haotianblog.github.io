---
layout:     post
title:      Vue知识点整理
subtitle:   H.T. Blog 知识点整理持续更新...
date:       2019-08-08
author:     haotian
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - Vue知识点整理
---

## 文章目录
1. 知识点目录

### 1. SPA单页面的理解，以及它的优缺点是什么？
SPA(single-page application)仅在Web页面初始化的时候加载相应的HTML、JavaScript和CSS。一旦加载完成，SPA不会因为用户的操作而进行页面的重新加载或者跳转；取而代之的是利用路由机制实现HTML的内容转换，UI用户的交互，避免页面的重新加载

优点：

1、用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；

2、基于上面一点，SPA 相对对服务器压力小；

3、前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：

1、初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；

2、前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；

3、SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

### 2. nextTick
在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态

1、新版本中默认是microtasks(宏任务)，v-on中会使用microtasks；

2、microtasks任务实现：

setImmediate / MessageChannel / setTimeout

## 3、 生命周期
####  _init_初始化
1、initLifecycle(vm)   // 初始化生命周期

2、initEvent(vm)   // 初始化事件

3、initRender(vm)   // 初始化渲染函数

4、callHook(vm, 'beforeCreated')   // 回调 beforeCreated 钩子函数

5、initInjections(vm)   // resolve  provide  after  data / props

6、initState(vm)   // 初始化 vm 的状态

7、initProvide(vm)   // resolve  provide  after  data / props

8、callHook(vm, 'created')   // vm 已经创建好，回调 created 钩子函数

9、$el / vm.$mount() // 进行元素挂载
## 4. computed和watch的区别和运用场景？
computed：是计算属性，依赖其他的属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值得时候才会重新计算computed的值；

watch：更多的是「观察」的作用，类似于某些数据的监听回调，每当监听数据发生变化时都会执行回调进行后续操作；

运用场景：

1、当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；

2、当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

## 5. 直接给一个数组项赋值，Vue 能检测到变化吗？
由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：

当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue

当你修改数组的长度时，例如：vm.items.length = newLength
```js
为了解决第一个问题，Vue 提供了以下操作方法：

// Vue.set

Vue.set(vm.items, indexOfItem, newValue)

// vm.$set，Vue.set的一个别名

vm.$set(vm.items, indexOfItem, newValue)

// Array.prototype.splice

vm.items.splice(indexOfItem, 1, newValue)

复制代码为了解决第二个问题，Vue 提供了以下操作方法：

// Array.prototype.splice

vm.items.splice(newLength)
```
## 6. Vue 的父组件和子组件生命周期钩子函数执行顺序?
```js
加载渲染过程

父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

子组件更新过程

父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

父组件更新过程
父 beforeUpdate -> 父 updated

销毁过程
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
```
## 7. keep-alive的理解
keep-alive 是 Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染；具有以下特性：

1、一般结合路由和动态组件一起使用，用于缓存组件；<br>
2、提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；<br>
3、对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。
## 8. Vue 组件间通信有哪几种方式？
（1）props / $emit 适用 父子组件通信

（2）ref 与 $parent / $children 适用 父子组件通信

ref: 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例

$parent / $children：访问父 / 子实例

（3）EventBus （$emit / $on）  适用于 父子、隔代、兄弟组件通信

这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

（4）$attrs/$listeners 适用于 隔代组件通信

$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。

$listeners：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件

（5）provide / inject 适用于 隔代组件通信

祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

（6）Vuex  适用于 父子、隔代、兄弟组件通信

Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。