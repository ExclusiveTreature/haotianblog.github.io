---
layout:     post
title:      知识点整理
subtitle:   H.T. Blog 知识点整理持续更新...
date:       2019-08-05
author:     haotian
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 知识点整理
---

## 文章目录
1. 知识点目录

## 1. 对象转原始类型是根据什么流程运行的？
对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：

    1、如果Symbol.toPrimitive()方法，优先调用再返回 
    2、调用valueOf()，如果转换为原始类型，则返回
    3、调用toString()，如果转换为原始类型，则返回
    4、如果都没有返回原始类型，会报错

    var obj = {
        value: 3,
        toString() {
            return '4'
        },
        valueOf() {
            return 5;
        },
        [Symbol.toPrimitive]() {
            return 6
        }
    }
    console.log(obj + 1); // 输出7

## 2. 如何让if(a == 1 && a == 2)条件成立？

其实就是上一个问题的应用。

    var a = {
    value: 0,
    valueOf: function() {
        this.value++;
        return this.value;
    }
    };
    console.log(a == 1 && a == 2);//true


## 3. 基本数据类型和引用类型区别？

    基本数据类型： undefined  null  Number  String  Boolean  Symbol  bigInt

    引用类型包括： Array  Function  Object  Date  RegExp  Math

## 4. 垃圾回收

    现在主要的还是标记清除的算法，A = null 只是做了一个释放引用的作用，让A原本对应的值失去引用，脱离执行环境，使变量在下一次垃圾回收时被找到并释放；

## 5. 内存泄漏

    对于持续运行的进程，一定要及时的释放不在用到的内存；轻则程序运行变慢，重则导致程序崩溃；

判断方法：

    1、浏览器法：打开控制台，选择memory，勾选timeline，进行录制，模拟用户操作，一段时间stop后查看内存占用情况；

    2、命令行法： 使用的node的process.memoryUsage方法，内存泄漏主要查看heapUsed字段；

    3、ES6中的weakMap和weakSet，表示这是弱引用，它们对于值的引用不计入垃圾回收机制中；

## 6. 作用域链

    当访问一个变量时，解释器首先在当前作用域查找标识符，如果没有找到，会到父作用域找，知道找到该变量的标识符；作用域链的顶端是全局对象，在全局环境中定义的变量，就会绑定到全局对象上；

    作用域链和原型继承查找的区别：如果去查找一个普通对象的属性，但是当前对象以及原型中都找不到，则会返回undefined，但查找属性在原型链中不存在的话就会抛出referenceError；

## 7. prototype、__proto__、constructor

    需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。

    原型链：__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。

    prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。

    constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。

## 8. 使用new操作符调用构造函数或者说new Foo(...)执行时，实际会经历4个步骤：

    1、创建一个继承自Foo.prototype的新对象；
    2、使用指定的参数调用构造函数Foo，并将this绑定到新创建的对象（因此this就指向这个新对象）。new Foo等同于new Foo(),相当于没有指定参数列表，Foo不带任何参数调用的情况；
    3、执行构造函数中的代码（为新对象添加属性）；
    4、由构造函数返回的对象就是new表达式的结果。如果没有显式的返回一个对象，则使用步骤1创建的对象；

## 9. 浅拷贝与深拷贝解析

    浅拷贝：简单理解为只解决了第一层的问题，拷贝了第一层的基本类型值和第一层引用类型地址；例如：slice()、concat、Object.assign()，以及展开语法；

    深拷贝：深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起被拷贝的时候即发生深拷贝。深拷贝相较于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

    例如：JSON.parse( JSON.stringify( ) )、jQuery.extend()、lodash.cloneDeep()

JSON.parse( JSON.stringify( obj ) )该方法为常用的深拷贝方法，但具有以下几点缺陷：

    1、会忽略undefined；
    2、会忽略Symbol；   
    3、不能序列化函数；
    4、不能解决循环引用的对象；
    5、不能正确处理new Date();
    6、不能处理正则；

## 10. 常见的web安全以及防护原理

1、sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法，也就是说，在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，同时将注入攻击的sql拼接起来，导致执行一些预期之外的操作；

    防范：1、对用户输入进行校验，2、不使用动态拼接sql

2、XSS(跨站脚本攻击)：往web页面插入恶意的HTML标签或者js代码；

    防范：1、尽量采用post而不使用get提交表单；2、避免cookie中泄漏用户的隐私

3、CSRF(跨站请求伪装)：通过伪装来自受信任用户的请求；

    防范：在客户端页面增加伪随机数，通过验证码

4、XSS和CSRF的区别：

    XSS是获取信息，不需要提前知道其他页面的代码和数据包，
    CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包
## 11. babel的编译原理
    1、babylon将ES6/ES7代码解析成AST
    2、babel-traverse对AST进行遍历转译，得到新的AST
    3、新AST通过babel-generator转换成ES5
