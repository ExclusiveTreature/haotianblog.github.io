---
layout:     post
title:      知识点整理
subtitle:   H.T. Blog 知识点整理持续更新...
date:       2019-08-05
author:     haotian
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 知识点整理
---

## 文章目录
1. 知识点目录

## 1. 对象转原始类型是根据什么流程运行的？
对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：

    1、如果Symbol.toPrimitive()方法，优先调用再返回 
    2、调用valueOf()，如果转换为原始类型，则返回
    3、调用toString()，如果转换为原始类型，则返回
    4、如果都没有返回原始类型，会报错

代码示例如下：

    var obj = {
        value: 3,
        toString() {
            return '4'
        },
        valueOf() {
            return 5;
        },
        [Symbol.toPrimitive]() {
            return 6
        }
    }
    console.log(obj + 1); // 输出7

## 2. 如何让if(a == 1 && a == 2)条件成立？

其实就是上一个问题的应用。

    var a = {
    value: 0,
    valueOf: function() {
        this.value++;
        return this.value;
    }
    };
    console.log(a == 1 && a == 2);//true


## 3. 基本数据类型和引用类型区别？

    基本数据类型： undefined  null  Number  String  Boolean  Symbol  bigInt

    引用类型包括： Array  Function  Object  Date  RegExp  Math

## 4. 垃圾回收

    现在主要的还是标记清除的算法，A = null 只是做了一个释放引用的作用，让A原本对应的值失去引用，脱离执行环境，使变量在下一次垃圾回收时被找到并释放；

## 5. 内存泄漏

    对于持续运行的进程，一定要及时的释放不在用到的内存；轻则程序运行变慢，重则导致程序崩溃；

判断方法：

    1、浏览器法：打开控制台，选择memory，勾选timeline，进行录制，模拟用户操作，一段时间stop后查看内存占用情况；

    2、命令行法： 使用的node的process.memoryUsage方法，内存泄漏主要查看heapUsed字段；

    3、ES6中的weakMap和weakSet，表示这是弱引用，它们对于值的引用不计入垃圾回收机制中；

## 6. 作用域链

    当访问一个变量时，解释器首先在当前作用域查找标识符，如果没有找到，会到父作用域找，知道找到该变量的标识符；作用域链的顶端是全局对象，在全局环境中定义的变量，就会绑定到全局对象上；

    作用域链和原型继承查找的区别：如果去查找一个普通对象的属性，但是当前对象以及原型中都找不到，则会返回undefined，但查找属性在原型链中不存在的话就会抛出referenceError；

## 7. prototype、__proto__、constructor

    需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。

    原型链：__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。

    prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。

    constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。

## 8. 使用new操作符调用构造函数或者说new Foo(...)执行时，实际会经历4个步骤：

    1、创建一个继承自Foo.prototype的新对象；
    2、使用指定的参数调用构造函数Foo，并将this绑定到新创建的对象（因此this就指向这个新对象）。new Foo等同于new Foo(),相当于没有指定参数列表，Foo不带任何参数调用的情况；
    3、执行构造函数中的代码（为新对象添加属性）；
    4、由构造函数返回的对象就是new表达式的结果。如果没有显式的返回一个对象，则使用步骤1创建的对象；

## 9. 浅拷贝与深拷贝解析

    浅拷贝：简单理解为只解决了第一层的问题，拷贝了第一层的基本类型值和第一层引用类型地址；例如：slice()、concat、Object.assign()，以及展开语法；

    深拷贝：深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起被拷贝的时候即发生深拷贝。深拷贝相较于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

    例如：JSON.parse( JSON.stringify( ) )、jQuery.extend()、lodash.cloneDeep()

JSON.parse( JSON.stringify( obj ) )该方法为常用的深拷贝方法，但具有以下几点缺陷：

    1、会忽略undefined；
    2、会忽略Symbol；   
    3、不能序列化函数；
    4、不能解决循环引用的对象；
    5、不能正确处理new Date();
    6、不能处理正则；

## 10. 常见的web安全以及防护原理

1、sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法，也就是说，在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，同时将注入攻击的sql拼接起来，导致执行一些预期之外的操作；

    防范：1、对用户输入进行校验，2、不使用动态拼接sql

2、XSS(跨站脚本攻击)：往web页面插入恶意的HTML标签或者js代码；

    防范：1、尽量采用post而不使用get提交表单；2、避免cookie中泄漏用户的隐私

3、CSRF(跨站请求伪装)：通过伪装来自受信任用户的请求；

    防范：在客户端页面增加伪随机数，通过验证码

4、XSS和CSRF的区别：

    XSS是获取信息，不需要提前知道其他页面的代码和数据包，
    CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包

## 11. babel的编译原理

    1、babylon将ES6/ES7代码解析成AST
    2、babel-traverse对AST进行遍历转译，得到新的AST
    3、新AST通过babel-generator转换成ES5

## 12、1.http和https

https的SSL加密是在传输层实现的。

(1)http和https的基本概念

    http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

    https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

    https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

(2)http和https的区别？

    http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。

    主要的区别如下：

    Https协议需要ca证书，费用较高。
    http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443
    http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

(3)https协议的工作原理

    客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

    客户使用https url访问服务器，则要求web 服务器建立ssl链接。
    web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。
    客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。
    客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。
    web服务器通过自己的私钥解密出会话密钥。
    web服务器通过会话密钥加密与客户端之间的通信。

(4)https协议的优点

    使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
    HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。
    HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。
    谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

(5)https协议的缺点

    https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。
    https缓存不如http高效，会增加数据开销。
    SSL证书也需要钱，功能越强大的证书费用越高。
    SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。

