---
layout:     post
title:      知识点整理
subtitle:   H.T. Blog 知识点整理持续更新...
date:       2019-08-05
author:     haotian
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - 知识点整理
---

## 文章目录
1. 知识点目录

## 1. 对象转原始类型是根据什么流程运行的？
对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：

1、如果Symbol.toPrimitive()方法，优先调用再返回 

2、调用valueOf()，如果转换为原始类型，则返回

3、调用toString()，如果转换为原始类型，则返回

4、如果都没有返回原始类型，会报错
```js
var obj = {
    value: 3,
    toString() {
        return '4'
    },
    valueOf() {
        return 5;
    },
    [Symbol.toPrimitive]() {
        return 6
    }
}
console.log(obj + 1); // 输出7
```
## 2. 如何让if(a == 1 && a == 2)条件成立？
其实就是上一个问题的应用。
```js
var a = {
  value: 0,
  valueOf: function() {
    this.value++;
    return this.value;
  }
};
console.log(a == 1 && a == 2);//true
```
## 3. 基本数据类型和引用类型区别？
```js
基本数据类型： undefined、 null、 Number、 String、 Boolean、 Symbol
```
```js
引用类型包括： Array、 Function、 Object、 Date、 RegExp
```
## 4. 垃圾回收
现在主要的还是标记清除的算法，A = null 只是做了一个释放引用的作用，让A原本对应的值失去引用，脱离执行环境，使变量在下一次垃圾回收时被找到并释放；
## 5. 内存泄漏
对于持续运行的进程，一定要及时的释放不在用到的内存；轻则程序运行变慢，重则导致程序崩溃；

判断方法：

1、浏览器法：打开控制台，选择memory，勾选timeline，进行录制，模拟用户操作，一段时间stop后查看内存占用情况；

2、命令行法： 使用的node的process.memoryUsage方法，内存泄漏主要查看heapUsed字段；

3、ES6中的weakMap和weakSet，表示这是弱引用，它们对于值的引用不计入垃圾回收机制中；
## 6. 作用域链
当访问一个变量时，解释器首先在当前作用域查找标识符，如果没有找到，会到父作用域找，知道找到该变量的标识符；作用域链的顶端是全局对象，在全局环境中定义的变量，就会绑定到全局对象上；

作用域链和原型继承查找的区别：如果去查找一个普通对象的属性，但是当前对象以及原型中都找不到，则会返回undefined，但查找属性在原型链中不存在的话就会抛出referenceError；
## 7. prototype、__proto__、constructor
需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。

原型链：__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值，会报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。

prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。

constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。
## 8. 7、使用new操作符调用构造函数或者说new Foo(...)执行时，实际会经历4个步骤：
1、创建一个继承自Foo.prototype的新对象；

2、使用指定的参数调用构造函数Foo，并将this绑定到新创建的对象（因此this就指向这个新对象）。new Foo等同于new Foo(),相当于没有指定参数列表，Foo不带任何参数调用的情况；

3、执行构造函数中的代码（为新对象添加属性）；

4、由构造函数返回的对象就是new表达式的结果。如果没有显式的返回一个对象，则使用步骤1创建的对象；